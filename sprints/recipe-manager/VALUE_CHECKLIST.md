# Value Checklist: recipe-manager
Generated: 2026-02-17T21:47:05.521880

## VRC Status
- Value Score: 33%
- Verified: 3/9
- Blocked: 0
- Recommendation: CONTINUE
- Summary: Iteration 8 QUICK VRC (Epic 1 scope): 3/9 deliverables verified (33%) -- UNCHANGED for SEVENTH consecutive iteration. EXECUTION DEADLOCK PERSISTS. No tasks completed since iteration 7. Zero file changes since iteration 2. The loop correctly diagnosed the root cause (decision engine P3 GENERATE_QC deadloop in iteration 5), but the deadlock remains unresolved. The agent_results state shows the precise bug: P3 fires every iteration (state.verifications empty, verifications_generated gate not set) and P6 EXECUTE is never reached, so the 9 pending tasks (VRC-1 code fix, 1.8 SPA shell, 1.9 recipe UI, etc.) are never dispatched. This is a decision engine configuration bug, not a strategy issue. No strategy change (execution_order, test_approach, etc.) can fix a deadlock at decision priority P3. RECOMMENDATION: ESCALATE. The loop needs human intervention to: (1) break the P3/P6 deadlock (manually set verifications_generated gate or raise P6 priority above P3), or (2) force-execute the three critical pending tasks manually (VRC-1, 1.8, 1.9). Without intervention, iteration 9 will show the same 0.33 score and zero progress. This sprint cannot continue under the current decision engine state.

## Tasks
- [x] **1.1**: Create project structure with backend/main.py (FastAPI app with CORS, static file mounting for frontend/, configurable PORT via env var defaulting to 8000), backend/requirements.txt (fastapi, uvicorn), and empty frontend/ directory structure (index.html, css/style.css, js/app.js, js/recipes.js, js/planner.js, js/shopping.js). The FastAPI app must serve the frontend at / via StaticFiles mount and expose API routes under /api/. Include startup logic to terminate any existing process on port 8000 before binding.
- [x] **1.2**: Create backend/database.py with SQLite connection management: get_db() function returning a connection to data/recipes.db with foreign keys enabled (PRAGMA foreign_keys=ON), init_db() function that creates ALL tables per PRD Section 2.1 schema: recipes, ingredients, meal_plans, shopping_lists, shopping_items (with all columns, constraints, CASCADE deletes, UNIQUE constraints, and default values). The data/ directory and .db file are auto-created if missing. init_db() is called on app startup. ALSO: on first run when recipes table is empty, insert 5 seed recipes (one per category: breakfast, lunch, dinner, snack, dessert) each with 3-6 ingredients spanning different grocery_sections and units per PRD Section 2.3.
- [x] **1.3**: Create backend/models.py with Pydantic models for recipe API request/response: IngredientCreate (quantity: float, unit: str, item: str, grocery_section: str with default other), RecipeCreate (title, description, category, prep_time_minutes, cook_time_minutes, servings, instructions, tags, ingredients: list[IngredientCreate]), IngredientResponse (adds id), RecipeResponse (adds id, created_at, updated_at, ingredients: list[IngredientResponse]), RecipeListItem (card-level fields without full ingredients for list endpoint).
- [x] **1.4**: Create backend/routes/recipes.py with full Recipe CRUD endpoints and query filtering: POST /api/recipes (create recipe with nested ingredients, return 201 with created resource), GET /api/recipes (list all recipes as card-level items with optional query parameter filtering: ?category= exact match, ?tag= partial match within comma-separated tags, ?search= across title, description, and ingredient items via JOIN; all three filters combinable with AND logic), GET /api/recipes/{id} (get single recipe with full ingredients), PUT /api/recipes/{id} (update recipe, replaces ingredients list entirely), DELETE /api/recipes/{id} (delete recipe, cascade removes ingredients and meal plan entries). All endpoints use proper HTTP status codes (201 for create, 404 for not found, 200 for success). Wire the router into main.py.
- [x] **1.7**: Write pytest integration tests in tests/test_api.py for all recipe API endpoints: test create recipe with ingredients (201 response, verify fields), test get recipe list (200, array), test get single recipe with ingredients (200, nested), test update recipe and replace ingredients (200, verify changes), test delete recipe (200, subsequent get returns 404), test cascading delete removes ingredients. Test all filter combinations: category filter, tag filter, search by title, search by ingredient name, combined filters. Test seed data: fresh DB has 5 recipes spanning all 5 categories, each with ingredients. Use httpx.AsyncClient with FastAPI TestClient and a fresh temp DB per test session.
- [ ] **1.8**: Build the SPA shell and dark theme: frontend/index.html with semantic structure (nav bar with Recipes/Meal Plan/Shopping List tabs, main content area), frontend/css/style.css with professional dark theme (dark background, light text, accent colors for interactive elements, card styling, responsive grid). frontend/js/app.js with hash-based SPA router (#recipes as default, #planner, #shopping), tab switching that highlights active tab, and shared utilities (API fetch wrapper, DOM helpers). The shell must render correctly at 1024px and 768px widths.
- [ ] **1.9**: Build the complete recipe UI in frontend/js/recipes.js: (1) Card grid layout showing all recipes (title, category badge, prep+cook time, tag chips). Filter bar with search input, category dropdown, tag filter — all calling GET /api/recipes with query params. (2) Recipe detail view showing full info (all fields, ingredients list, instructions) with Edit and Delete buttons. Delete shows confirmation then calls DELETE API. (3) Create/edit form modal with all fields plus dynamic ingredient rows (add/remove). Form submits via POST (create) or PUT (edit). On success, modal closes and collection refreshes. Add Recipe button opens empty form.
- [ ] **2.2**: Create backend/routes/meals.py with meal plan API endpoints: GET /api/meals?week={ISO date} returns all meal plan entries for that week with recipe title, prep_time_minutes, and cook_time_minutes included in each entry (JOIN with recipes table). PUT /api/meals upserts a meal plan entry (body: week_start, day_of_week, meal_slot, recipe_id) — inserts or replaces existing entry for that slot. DELETE /api/meals/{id} removes a specific meal plan entry. Add Pydantic models for meal plan request/response to models.py. Wire router into main.py.
- [ ] **2.3**: Write pytest integration tests for meal plan API in tests/test_api.py (or tests/test_meals.py): test assign recipe to slot (PUT), test get week plan returns assignment with recipe title and times, test upsert replaces existing assignment, test delete clears slot, test cascading delete (delete recipe removes meal plan entries), test invalid recipe_id returns error, test week navigation returns different data for different weeks.
- [ ] **2.4**: Build the complete weekly meal planner view in frontend/js/planner.js: (1) 7-column grid (Mon-Sun) with 4 rows (breakfast, lunch, dinner, snack). Week navigation with prev/next arrows and This Week button. Week date range displayed in header (e.g. Feb 17 - Feb 23, 2026). Day summary row at the bottom of each column showing total prep+cook time for that day (sum of all assigned recipes prep_time_minutes + cook_time_minutes, displayed as e.g. 1h 25m). (2) Recipe picker modal: clicking the + button on an empty slot opens a modal containing a searchable recipe list (fetched via GET /api/recipes?search=). Selecting a recipe fires PUT /api/meals for that slot and the grid refreshes. (3) Slot interactions: clicking an assigned recipe title shows a 3-option context menu (View Recipe, Swap, Clear). View navigates to #recipes with that recipe detail open. Clear calls DELETE /api/meals/{id}. Swap opens the recipe picker and on selection fires PUT /api/meals to replace. (4) Copy-to-multiple-slots: a Copy to Slots button appears in the slot context menu (alongside View/Swap/Clear). Clicking it opens a modal showing a 7x4 grid of checkboxes (days x meal slots). User checks target slots and clicks Confirm. The frontend fires one PUT /api/meals call per checked slot sequentially. On completion the planner grid refreshes. No batch API endpoint.
- [ ] **3.1**: Implement unit normalization engine and shopping list API endpoints in backend/routes/shopping.py. Unit normalization: pure function that takes a list of (quantity, unit, item, grocery_section) tuples, aggregates by (item normalized to lowercase, compatible grocery_section), and normalizes units. Volume: tsp->tbsp->cup (3 tsp=1 tbsp, 16 tbsp=1 cup). Weight: oz->lb (16 oz=1 lb). Count: whole/piece/each equivalent. Upconvert to largest unit yielding qty>=1, never downconvert, 1 decimal place. Incompatible units = separate lines. API endpoints: POST /api/shopping/generate (aggregate from week meal plan, replace existing list with confirmation handled by frontend), GET /api/shopping/current (return list with items grouped by section), PATCH /api/shopping/items/{id} (toggle checked), POST /api/shopping/items (add manual item with source=manual), DELETE /api/shopping/items/{id} (remove item). Add Pydantic models to models.py. Wire router into main.py.
- [ ] **3.2**: Write pytest integration tests for shopping list functionality in tests/test_api.py (or tests/test_shopping.py): Test unit normalization edge cases (volume chain, weight chain, count equivalents, incompatible units, upconversion thresholds, never-downconvert, decimal precision). Test aggregation (two recipes using same ingredient merge into one line). Test API endpoints: generate from meal plan with recipes assigned, get current list, toggle checked, add manual item, delete item. Test persistence: checked state survives server restart. Test replace: generating new list deletes old one.
- [ ] **3.3**: Build the shopping list view in frontend/js/shopping.js: (1) Generate from This Week button that reads the currently displayed week from the planner state (the same week_start value the planner tab is showing; default is the current calendar week with Monday as start). Calls POST /api/shopping/generate with that week_start. If GET /api/shopping/current returns an existing list, show a browser confirm() dialog (Are you sure? This will replace your current shopping list.) before generating. (2) Display items grouped by grocery section with section headers in fixed order: produce, meat, dairy, pantry, frozen, other. Within each section, unchecked items appear first sorted alphabetically by item name, then checked items sorted alphabetically. (3) Each item row shows: checkbox (left), quantity + unit (e.g. 3 cups), item name. Checking/unchecking calls PATCH /api/shopping/items/{id} to toggle. Checked items show CSS strikethrough text and reduced opacity (0.6). (4) Add Item input field at the top with an Add button. Submitting calls POST /api/shopping/items with source=manual, unit=whole, quantity=1, grocery_section=other. The new item appears immediately in the other section. (5) Each item row has a small X delete button on the right. Clicking calls DELETE /api/shopping/items/{id} and removes the row. (6) Item count summary at top: X items, Y checked (updated on every check/add/delete). (7) On tab switch to #shopping, calls GET /api/shopping/current and renders the full list, preserving checked state from the database.
- [ ] **1.10**: End-to-end verification of the full recipe lifecycle through the UI: start the server, confirm 5 seed recipes appear as cards in the dark-themed grid, use the filter bar (search by ingredient, filter by category, filter by tag, combine all three), open a recipe detail view, create a new recipe with dynamic ingredient rows, verify it appears in the collection, edit the recipe and confirm changes persist, delete the recipe and confirm it is gone. Verify responsive layout at 1024px and 768px. This task creates or updates the loop verification script at .loop/verifications/run_all.py to programmatically verify key acceptance criteria.
- [ ] **VRC-1**: Fix recipe search to include ingredient items via JOIN. Currently GET /api/recipes?search=X only searches title and description fields. The SQL query in routes/recipes.py list_recipes() must LEFT JOIN with ingredients table and add OR i.item LIKE ? to the WHERE clause, with SELECT DISTINCT to avoid duplicate results.

## Verifications