# Value Checklist: recipe-manager
Generated: 2026-02-17T23:01:44.448408

## VRC Status
- Value Score: 100%
- Verified: 9/9
- Blocked: 0
- Recommendation: SHIP_READY
- Summary: Fallback VRC: carried forward from iteration 18 (100%)

## Tasks
- [x] **1.1**: Create project structure with backend/main.py (FastAPI app with CORS, static file mounting for frontend/, configurable PORT via env var defaulting to 8000), backend/requirements.txt (fastapi, uvicorn), and empty frontend/ directory structure (index.html, css/style.css, js/app.js, js/recipes.js, js/planner.js, js/shopping.js). The FastAPI app must serve the frontend at / via StaticFiles mount and expose API routes under /api/. Include startup logic to terminate any existing process on port 8000 before binding.
- [x] **1.2**: Create backend/database.py with SQLite connection management: get_db() function returning a connection to data/recipes.db with foreign keys enabled (PRAGMA foreign_keys=ON), init_db() function that creates ALL tables per PRD Section 2.1 schema: recipes, ingredients, meal_plans, shopping_lists, shopping_items (with all columns, constraints, CASCADE deletes, UNIQUE constraints, and default values). The data/ directory and .db file are auto-created if missing. init_db() is called on app startup. ALSO: on first run when recipes table is empty, insert 5 seed recipes (one per category: breakfast, lunch, dinner, snack, dessert) each with 3-6 ingredients spanning different grocery_sections and units per PRD Section 2.3.
- [x] **1.3**: Create backend/models.py with Pydantic models for recipe API request/response: IngredientCreate (quantity: float, unit: str, item: str, grocery_section: str with default other), RecipeCreate (title, description, category, prep_time_minutes, cook_time_minutes, servings, instructions, tags, ingredients: list[IngredientCreate]), IngredientResponse (adds id), RecipeResponse (adds id, created_at, updated_at, ingredients: list[IngredientResponse]), RecipeListItem (card-level fields without full ingredients for list endpoint).
- [x] **1.4**: Create backend/routes/recipes.py with full Recipe CRUD endpoints and query filtering: POST /api/recipes (create recipe with nested ingredients, return 201 with created resource), GET /api/recipes (list all recipes as card-level items with optional query parameter filtering: ?category= exact match, ?tag= partial match within comma-separated tags, ?search= across title, description, and ingredient items via JOIN; all three filters combinable with AND logic), GET /api/recipes/{id} (get single recipe with full ingredients), PUT /api/recipes/{id} (update recipe, replaces ingredients list entirely), DELETE /api/recipes/{id} (delete recipe, cascade removes ingredients and meal plan entries). All endpoints use proper HTTP status codes (201 for create, 404 for not found, 200 for success). Wire the router into main.py.
- [x] **1.7**: Write pytest integration tests in tests/test_api.py for all recipe API endpoints: test create recipe with ingredients (201 response, verify fields), test get recipe list (200, array), test get single recipe with ingredients (200, nested), test update recipe and replace ingredients (200, verify changes), test delete recipe (200, subsequent get returns 404), test cascading delete removes ingredients. Test all filter combinations: category filter, tag filter, search by title, search by ingredient name, combined filters. Test seed data: fresh DB has 5 recipes spanning all 5 categories, each with ingredients. Use httpx.AsyncClient with FastAPI TestClient and a fresh temp DB per test session.
- [x] **E1-1**: Fix ingredient search in backend/routes/recipes.py list_recipes(). The current SQL query at lines 79-81 only searches title and description fields. Must add LEFT JOIN ingredients i ON i.recipe_id = r.id to the FROM clause, add OR i.item LIKE ? to the WHERE clause search condition, and change SELECT r.* to SELECT DISTINCT r.* to prevent duplicate results when multiple ingredients match. This is a targeted fix to ~5 lines of SQL in one function.
- [x] **E1-2**: Build the SPA shell and professional dark theme. Rewrite frontend/index.html with semantic HTML structure: top navigation bar with three tabs (Recipes, Meal Plan, Shopping List), main content area with id=app for dynamic content. Create frontend/css/style.css with a professional dark theme: dark background (#1a1a2e or similar), light text (#eee), accent color for interactive elements, styled nav bar with active tab highlighting, card component styles, modal overlay styles, form input styles, button styles (primary/danger/ghost variants), responsive grid breakpoints for 1024px and 768px widths, CSS custom properties for theme colors. Create frontend/js/app.js with: hash-based SPA router defaulting to #recipes, route change listener that calls view-specific render functions, active tab state management, shared API fetch wrapper (async function that handles JSON request/response and error display), DOM helper utilities for creating elements. The Recipes tab must be active by default on page load.
- [x] **E1-3**: Build the recipe collection view with card grid and filter bar in frontend/js/recipes.js. This file implements the #recipes view. (1) Filter bar at top: search text input with debounced keyup (300ms) calling GET /api/recipes?search=, category dropdown (All, breakfast, lunch, dinner, snack, dessert) calling GET /api/recipes?category=, tag filter input calling GET /api/recipes?tag=. All three filters combine: changing any filter re-fetches with all current filter values as query params. (2) Card grid below filters: responsive CSS grid of recipe cards. Each card shows: recipe title as heading, category badge (colored pill), total time (prep + cook displayed as e.g. 35 min), and tag chips (each tag as a small pill). Cards are clickable -- clicking navigates to recipe detail view (task E1-4). (3) Add Recipe button (prominent, in filter bar area) that opens the create form modal (task E1-5). On initial load of #recipes view, fetch GET /api/recipes with no filters to show all recipes. The 5 seed recipes must appear as cards immediately.
- [ ] **E1-4**: Build the recipe detail view in frontend/js/recipes.js (same file as E1-3, extending it). When a recipe card is clicked, the collection view is replaced by a detail view showing the full recipe: title, description, category badge, prep time, cook time, total time, servings, tags as chips, ingredients list (each showing quantity + unit + item with grocery section label), and instructions text (preserving newlines for numbered steps). Two action buttons: Edit (opens the create/edit form modal pre-filled with this recipe data -- wired to task E1-5) and Delete (shows browser confirm dialog, on confirm calls DELETE /api/recipes/{id}, then navigates back to collection view). A Back button/link returns to the collection view. The detail view fetches from GET /api/recipes/{id} to ensure complete data including ingredients.
- [ ] **E1-5**: Build the recipe create/edit form modal in frontend/js/recipes.js (same file, extending it). A modal overlay containing a form with all recipe fields: title (text, required), description (textarea), category (dropdown: breakfast/lunch/dinner/snack/dessert, required), prep_time_minutes (number), cook_time_minutes (number), servings (number), instructions (textarea), tags (text, comma-separated). Dynamic ingredients section: a container with ingredient rows, each row having quantity (number input), unit (text input or dropdown with common units), item (text input), grocery_section (dropdown: produce/meat/dairy/pantry/frozen/other). An Add Ingredient button appends a new empty row. Each row has a Remove button (X) that removes that row (minimum 1 row). The form opens in two modes: (a) Create mode via the Add Recipe button -- all fields empty, submits POST /api/recipes. (b) Edit mode via the detail view Edit button -- all fields pre-populated from the recipe data including all ingredient rows, submits PUT /api/recipes/{id}. On successful submit, the modal closes and the collection view refreshes showing the new/updated recipe. Validation: title and category are required; at least one ingredient row must have item filled.
- [ ] **E1-6**: Ensure all 62 pytest integration tests pass and the full recipe lifecycle works end-to-end through the UI. (1) Run pytest sprints/recipe-manager/tests/test_api.py and verify all 62 tests pass (including the ingredient search test that was previously failing due to VRC-1). Fix any test failures by correcting backend code or test expectations. (2) Create or update the verification script at sprints/recipe-manager/.loop/verifications/run_all.py that programmatically verifies key Epic 1 acceptance criteria: server starts on port 8000, GET /api/recipes returns 5 seed recipes, ingredient search works (search=oats returns results), frontend index.html is served with expected DOM structure (nav, content area), CSS and JS files are served. The script must exit 0 on success, non-zero on failure. (3) Manually verify via browser or automated check: open localhost:8000, see 5 seed recipe cards, use filters, create a recipe, view detail, edit, delete, confirm dark theme at 1024px and 768px.

## Verifications