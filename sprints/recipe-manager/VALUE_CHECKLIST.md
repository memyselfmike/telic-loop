# Value Checklist: recipe-manager
Generated: 2026-02-18T00:58:39.333662

## VRC Status
- Value Score: 100%
- Verified: 8/8
- Blocked: 0
- Recommendation: SHIP_READY
- Summary: Epic 2 (Weekly Meal Planner) delivers full value — all 8 deliverables verified at EXISTS+WORKS+VALUE level. (1) Meal plan API: GET/PUT/DELETE endpoints with recipe_title and total_time in response, all 9 meal plan tests pass. (2) meal_plans table: CASCADE delete on recipe_id FK, uniqueness enforced via application-level DELETE-before-INSERT. (3) Planner grid: 7-column (Mon-Sun) x 4-row (breakfast/lunch/dinner/snack) table renders correctly. (4) Recipe picker modal: searchable list with 200ms debounced filtering by title/category/tags. (5) Slot interactions: assign via picker, view/swap/clear/copy-to-slots via action popup, hover X for quick clear, keyboard accessible. (6) Week navigation: prev/next/Today buttons with date range label, weeks isolated. (7) Day summary row: buildTotalRow() sums total_time per day, verified 25min=15+10 for Monday with 2 recipes. (8) Cascading delete: verified recipe deletion clears 3 meal plan slots, no orphaned data. All 62 pytest tests pass (4.23s). Both verification scripts (value_epic2_complete.py, value_planner_persistence_cascade.py) report PASS on all acceptance criteria. Meal plans persist across navigation and reloads. Bonus: copy-to-slots meal prep feature enables assigning same recipe to multiple slots at once. SHIP_READY.

## Tasks
- [x] **E1-1**: Set up project structure with backend/main.py (FastAPI app with CORS, static file mounting for frontend/, configurable PORT via env var defaulting to 8000), backend/requirements.txt (fastapi, uvicorn), and frontend directory structure (index.html, css/style.css, js/app.js, js/recipes.js, js/planner.js, js/shopping.js). FastAPI serves frontend at / via StaticFiles mount and exposes API routes under /api/.
- [x] **E1-2**: Create backend/database.py with SQLite connection management: get_db() function returning a connection to data/recipes.db with foreign keys enabled (PRAGMA foreign_keys=ON), init_db() function that creates recipes table (id, title, description, category, prep_time_minutes, cook_time_minutes, servings, instructions, tags, created_at, updated_at) and ingredients table (id, recipe_id FK CASCADE, quantity, unit, item, grocery_section, sort_order). Data directory and .db file auto-created if missing. init_db() called on app startup. On first run when recipes table is empty, insert 5 seed recipes (one per category: breakfast, lunch, dinner, snack, dessert) each with 3-6 ingredients spanning different grocery_sections and units per PRD Section 2.3.
- [x] **E1-3**: Create backend/models.py with Pydantic v2 models for recipe API request/response: IngredientCreate (quantity: float, unit: str, item: str, grocery_section: str with default other), RecipeCreate (title, description, category, prep_time_minutes, cook_time_minutes, servings, instructions, tags, ingredients: list[IngredientCreate]), IngredientResponse (adds id, sort_order), RecipeResponse (adds id, created_at, updated_at, ingredients: list[IngredientResponse]), RecipeListItem (card-level fields: id, title, category, prep_time_minutes, cook_time_minutes, tags -- without full ingredients for efficient list endpoint).
- [x] **E1-4**: Create backend/routes/recipes.py with full Recipe CRUD endpoints and query filtering: POST /api/recipes (create recipe with nested ingredients, return 201), GET /api/recipes (list recipes with optional ?category= exact match, ?tag= partial match in comma-separated tags, ?search= across title, description, AND ingredient items via LEFT JOIN with SELECT DISTINCT; all three combinable with AND logic), GET /api/recipes/{id} (single recipe with full ingredients), PUT /api/recipes/{id} (update recipe, replace ingredients list entirely), DELETE /api/recipes/{id} (cascade removes ingredients). Wire router into main.py. All endpoints use proper HTTP status codes (201 create, 404 not found, 200 success).
- [x] **E1-5**: Write pytest integration tests in tests/test_api.py for all recipe API endpoints: test create recipe with ingredients (201, verify fields), test get recipe list (200, array), test get single recipe with ingredients (200, nested), test update recipe and replace ingredients (200, verify changes), test delete recipe (200, subsequent GET 404), test cascading delete removes ingredients. Test all filter combinations: category filter, tag filter, search by title, search by ingredient name (via JOIN), combined filters. Test seed data: fresh DB has 5 recipes spanning all 5 categories with ingredients. Use httpx.AsyncClient with FastAPI TestClient and a fresh temp DB per test session.
- [x] **E1-6**: Build the SPA shell and professional dark theme. Rewrite frontend/index.html with semantic HTML: top navigation bar with three tabs (Recipes, Meal Plan, Shopping List), main content area with id=app. Create frontend/css/style.css with professional dark theme: dark background (#1a1a2e or similar), light text (#eee), accent color for interactive elements, styled nav bar with active tab highlighting, card component styles, modal overlay styles, form input styles, button styles (primary/danger/ghost variants), responsive grid breakpoints for 1024px and 768px. Create frontend/js/app.js with: hash-based SPA router defaulting to #recipes, route change listener calling view-specific render functions, active tab state management, shared async API fetch wrapper with error handling, DOM helper utilities. Recipes tab active by default on load.
- [x] **E1-7**: Build the recipe collection view with card grid and filter bar in frontend/js/recipes.js. (1) Filter bar at top: search text input with debounced keyup (300ms), category dropdown (All/breakfast/lunch/dinner/snack/dessert), tag filter input. All three filters combine: changing any re-fetches GET /api/recipes with all current filter values as query params. (2) Card grid: responsive CSS grid of recipe cards, each showing title as heading, category badge (colored pill), total time (prep+cook as e.g. 35 min), tag chips. Cards clickable -- click opens recipe detail view (E1-8). (3) Add Recipe button in filter bar area opens create form modal (E1-9). On initial load of #recipes view, fetch GET /api/recipes with no filters to show all. 5 seed recipes must appear as cards immediately.
- [x] **E1-8**: Build the recipe detail view in frontend/js/recipes.js (extending it). When a recipe card is clicked, open a modal showing the full recipe: title, description, category badge, prep time, cook time, total time, servings, tags as chips, ingredients list (each showing quantity + unit + item with grocery section label), and instructions (preserving newlines for numbered steps). Two action buttons: Edit (opens create/edit form modal pre-filled -- wired to E1-9) and Delete (browser confirm dialog, on confirm calls DELETE /api/recipes/{id}, closes modal, refreshes collection). Back button closes modal. Detail view fetches GET /api/recipes/{id} for complete data including ingredients.
- [x] **E1-9**: Build the recipe create/edit form modal in frontend/js/recipes.js (extending it). Modal overlay with form containing: title (text, required), description (textarea), category (dropdown: breakfast/lunch/dinner/snack/dessert, required), prep_time_minutes (number), cook_time_minutes (number), servings (number), instructions (textarea), tags (text, comma-separated). Dynamic ingredients section: container with ingredient rows, each row having quantity (number), unit (text/dropdown), item (text), grocery_section (dropdown: produce/meat/dairy/pantry/frozen/other). Add Ingredient button appends new empty row. Each row has Remove (X) button (minimum 1 row). Two modes: (a) Create via Add Recipe button -- empty fields, POST /api/recipes. (b) Edit via detail view Edit button -- pre-populated from recipe data including all ingredient rows, PUT /api/recipes/{id}. On success, modal closes and collection refreshes. Validation: title and category required; at least one ingredient with item filled.
- [x] **E1-10**: End-to-end verification of full recipe lifecycle through the UI. (1) Run pytest sprints/recipe-manager/tests/test_api.py and verify all tests pass. Fix any failures. (2) Create or update verification script at sprints/recipe-manager/.loop/verifications/run_all.py that programmatically verifies Epic 1 acceptance criteria: server starts on port 8000, GET /api/recipes returns 5 seed recipes, ingredient search works (search=oats returns results), frontend index.html served with expected DOM structure, CSS and JS files served. Script exits 0 on success, non-zero on failure. (3) Verify via browser evaluation: open localhost:8000, see 5 seed recipe cards, use filters, create a recipe, view detail, edit, delete. Confirm dark theme at 1024px and 768px.
- [x] **E2-1**: Build the weekly meal planner grid view in planner.js: render a 7-column (Mon-Sun) x 4-row (breakfast, lunch, dinner, snack) HTML table using the existing CSS classes (.meal-table, .meal-cell, .meal-row-label, etc.). On load, calculate the current week start (Monday ISO date), call GET /api/meals?week={weekStart} to fetch assigned meals, and populate cells — empty cells show a "+" add button (.meal-cell-add), filled cells show recipe title (.meal-cell-title) and time (.meal-cell-time). Include a day header row (th per day: Mon-Sun) and a day total summary row (.day-total-row) showing total prep+cook time per column. Use window.App.el() for DOM construction and window.App.apiFetch() for API calls.
- [x] **E2-2**: Implement week navigation controls in planner.js: add a navigation bar (.planner-week-nav) above the grid with Previous/Next week arrow buttons and a "This Week" button. Clicking Previous subtracts 7 days from the current weekStart, clicking Next adds 7 days, and "This Week" resets to the current Monday. Display the week range as a label (e.g., "Feb 16 – Feb 22, 2026") in a .week-label element. Each navigation action recalculates weekStart, calls GET /api/meals?week={newWeekStart}, and re-renders the grid cells and day totals. Persist the current weekStart in a module-level variable so re-renders maintain position.
- [x] **E2-3**: Implement the recipe picker modal in planner.js: when the user clicks a "+" (empty cell) in the meal grid, open a modal (using window.App.openModal) titled "Pick a Recipe" containing a search input (.picker-search) and a scrollable list (.picker-list) of all recipes fetched from GET /api/recipes. Each list item (.picker-item) shows recipe title (.picker-item-title) and time + category (.picker-item-meta). The search input filters the list in real-time by title (case-insensitive substring match). Clicking a recipe item calls PUT /api/meals with {week_start, day_of_week, meal_slot, recipe_id}, closes the modal, and updates the clicked cell to show the recipe title and time without full page re-render.
- [x] **E2-4**: Implement slot interactions for assigned recipe cells in planner.js: when the user clicks a cell that already has a recipe assigned, show an action popup or context menu with three options: (1) "View Recipe" — navigates to #recipes and could open recipe detail (or shows recipe info in a modal), (2) "Swap" — opens the recipe picker modal to replace the current recipe in this slot (reuses E2-3 picker, PUT /api/meals upserts), (3) "Clear" — calls DELETE /api/meals/{mealId} and updates the cell back to the empty "+" state. Additionally, show a remove button (.meal-cell-remove) on hover that directly clears the slot without the menu for quick removal. After any slot change, recalculate and update the day total row for that column.
- [x] **E2-5**: Implement copy-to-slots (meal prep) workflow in planner.js: add a "Copy to slots..." option in the assigned-recipe action menu (from E2-4). When selected, open a modal showing a checkbox grid of all 28 slots (7 days x 4 meals) where the user can select multiple target slots. Pre-check the current slot. A "Copy" button fires one PUT /api/meals call per selected slot (sequentially or with Promise.all), then refreshes the grid. This enables the PRD meal-prep scenario: same lunch Monday-Friday. Show a toast summarizing how many slots were filled (e.g., "Copied to 5 slots"). Handle errors gracefully — if some PUTs fail, report which succeeded.
- [x] **E2-6**: Verify meal plan persistence and cascade delete behavior in planner.js integration: (1) Persistence — assign recipes to several slots, navigate to #recipes and back to #planner, confirm slots still show assigned recipes (data fetched fresh from API each time). Navigate between weeks and back, confirm data persists. (2) Cascade delete — assign a recipe to a planner slot, switch to #recipes, delete that recipe, switch back to #planner, confirm the slot is now empty (the meal_plans row was cascade-deleted in SQLite). Ensure no errors occur when rendering a week that had cascade-deleted entries. (3) Day totals accuracy — assign multiple recipes to one day, verify the day total row sums prep+cook time correctly.

## Verifications