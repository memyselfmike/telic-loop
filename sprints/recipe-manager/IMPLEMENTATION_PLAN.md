# Implementation Plan (rendered from state)

Generated: 2026-02-17T23:40:02.589636


## Foundation

- [x] **E1-1**: Set up project structure with backend/main.py (FastAPI app with CORS, static file mounting for frontend/, configurable PORT via env var defaulting to 8000), backend/requirements.txt (fastapi, uvicorn), and frontend directory structure (index.html, css/style.css, js/app.js, js/recipes.js, js/planner.js, js/shopping.js). FastAPI serves frontend at / via StaticFiles mount and exposes API routes under /api/.
  - Value: Establishes the runnable application skeleton so all subsequent tasks have a working server to build upon -- without this foundation, nothing can be tested or demonstrated
  - Acceptance: Running uvicorn backend.main:app from sprints/recipe-manager/ starts on port 8000. GET http://localhost:8000/ returns index.html. GET http://localhost:8000/api/recipes returns 200 response. No port conflict errors.

- [x] **E1-2**: Create backend/database.py with SQLite connection management: get_db() function returning a connection to data/recipes.db with foreign keys enabled (PRAGMA foreign_keys=ON), init_db() function that creates recipes table (id, title, description, category, prep_time_minutes, cook_time_minutes, servings, instructions, tags, created_at, updated_at) and ingredients table (id, recipe_id FK CASCADE, quantity, unit, item, grocery_section, sort_order). Data directory and .db file auto-created if missing. init_db() called on app startup. On first run when recipes table is empty, insert 5 seed recipes (one per category: breakfast, lunch, dinner, snack, dessert) each with 3-6 ingredients spanning different grocery_sections and units per PRD Section 2.3.
  - Value: Enables ALL persistent data storage for recipes and ingredients, and eliminates cold start by providing 5 seed recipes -- the user sees a populated app immediately on first visit
  - Acceptance: After server startup, data/recipes.db exists with recipes (11 columns) and ingredients (7 columns with FK CASCADE) tables. PRAGMA foreign_keys returns 1. On first startup, GET /api/recipes returns 5 seed recipes spanning all categories with ingredients. On subsequent startup, no duplicate seeds.
  - Deps: E1-1

- [x] **E1-3**: Create backend/models.py with Pydantic v2 models for recipe API request/response: IngredientCreate (quantity: float, unit: str, item: str, grocery_section: str with default other), RecipeCreate (title, description, category, prep_time_minutes, cook_time_minutes, servings, instructions, tags, ingredients: list[IngredientCreate]), IngredientResponse (adds id, sort_order), RecipeResponse (adds id, created_at, updated_at, ingredients: list[IngredientResponse]), RecipeListItem (card-level fields: id, title, category, prep_time_minutes, cook_time_minutes, tags -- without full ingredients for efficient list endpoint).
  - Value: Provides validated data contracts between frontend and backend, preventing malformed data from corrupting the database and ensuring consistent API responses
  - Acceptance: Importing models in Python works without errors. RecipeCreate validates required fields (title, category) and rejects missing required fields. IngredientCreate accepts valid grocery_section values. RecipeResponse includes nested ingredients list. RecipeListItem excludes ingredients for card-level use.
  - Deps: E1-1


## Core

- [x] **E1-4**: Create backend/routes/recipes.py with full Recipe CRUD endpoints and query filtering: POST /api/recipes (create recipe with nested ingredients, return 201), GET /api/recipes (list recipes with optional ?category= exact match, ?tag= partial match in comma-separated tags, ?search= across title, description, AND ingredient items via LEFT JOIN with SELECT DISTINCT; all three combinable with AND logic), GET /api/recipes/{id} (single recipe with full ingredients), PUT /api/recipes/{id} (update recipe, replace ingredients list entirely), DELETE /api/recipes/{id} (cascade removes ingredients). Wire router into main.py. All endpoints use proper HTTP status codes (201 create, 404 not found, 200 success).
  - Value: Enables the core recipe management workflow -- users can create, read, update, delete, search, and filter their recipes through the API, which is the data backbone for the entire app
  - Acceptance: POST /api/recipes returns 201 with id. GET /api/recipes returns list. GET /api/recipes/{id} returns recipe with ingredients. PUT updates and replaces ingredients. DELETE returns 200, subsequent GET returns 404. Category filter returns only matching. Search by ingredient name works (search=oats returns Classic Oatmeal via JOIN). Tag filter works. Combined filters (category=dinner&search=pasta&tag=quick) returns only recipes matching ALL. Empty result returns [].
  - Deps: E1-2, E1-3

- [x] **E1-5**: Write pytest integration tests in tests/test_api.py for all recipe API endpoints: test create recipe with ingredients (201, verify fields), test get recipe list (200, array), test get single recipe with ingredients (200, nested), test update recipe and replace ingredients (200, verify changes), test delete recipe (200, subsequent GET 404), test cascading delete removes ingredients. Test all filter combinations: category filter, tag filter, search by title, search by ingredient name (via JOIN), combined filters. Test seed data: fresh DB has 5 recipes spanning all 5 categories with ingredients. Use httpx.AsyncClient with FastAPI TestClient and a fresh temp DB per test session.
  - Value: Provides automated verification that the recipe API works correctly across all CRUD operations and filter combinations, catching regressions before they reach the user
  - Acceptance: All tests pass with pytest. Tests cover: CRUD operations (create, read, update, delete), filter operations (category, tag, search, combined), seed data verification (5 recipes on fresh DB), cascade delete (ingredients removed when recipe deleted), ingredient search via JOIN. At least 15 test functions.
  - Deps: E1-4

- [x] **E1-6**: Build the SPA shell and professional dark theme. Rewrite frontend/index.html with semantic HTML: top navigation bar with three tabs (Recipes, Meal Plan, Shopping List), main content area with id=app. Create frontend/css/style.css with professional dark theme: dark background (#1a1a2e or similar), light text (#eee), accent color for interactive elements, styled nav bar with active tab highlighting, card component styles, modal overlay styles, form input styles, button styles (primary/danger/ghost variants), responsive grid breakpoints for 1024px and 768px. Create frontend/js/app.js with: hash-based SPA router defaulting to #recipes, route change listener calling view-specific render functions, active tab state management, shared async API fetch wrapper with error handling, DOM helper utilities. Recipes tab active by default on load.
  - Value: Provides the visual foundation and navigation framework for the entire app -- the user sees a polished dark-themed interface and can navigate between views, the entry point to ALL user interactions
  - Acceptance: Opening localhost:8000 shows dark-themed page with nav bar containing three labeled tabs. Recipes tab highlighted/active by default. Clicking tabs changes URL hash (#recipes, #planner, #shopping) and shows different content. Dark theme has dark background, light text, accent colors. Layout renders cleanly at 1024px and 768px without horizontal scroll. No console errors. CSS defines: nav styling, card grid, modal overlay, form inputs, button variants, responsive breakpoints.

- [x] **E1-7**: Build the recipe collection view with card grid and filter bar in frontend/js/recipes.js. (1) Filter bar at top: search text input with debounced keyup (300ms), category dropdown (All/breakfast/lunch/dinner/snack/dessert), tag filter input. All three filters combine: changing any re-fetches GET /api/recipes with all current filter values as query params. (2) Card grid: responsive CSS grid of recipe cards, each showing title as heading, category badge (colored pill), total time (prep+cook as e.g. 35 min), tag chips. Cards clickable -- click opens recipe detail view (E1-8). (3) Add Recipe button in filter bar area opens create form modal (E1-9). On initial load of #recipes view, fetch GET /api/recipes with no filters to show all. 5 seed recipes must appear as cards immediately.
  - Value: Enables the cook to browse their recipe collection at a glance and quickly find specific recipes using combinable search and filters -- the primary entry point to the Recipe Collection workflow
  - Acceptance: Navigating to localhost:8000 shows filter bar with search input, category dropdown, tag filter. Below it, 5 seed recipe cards in responsive grid. Each card shows title, colored category badge, total time, tag chips. Typing in search (after 300ms debounce) re-fetches matching recipes. Category dropdown filters. Combined filters work (category=dinner + search=broccoli shows only Beef Stir Fry). Clearing filters shows all 5. Add Recipe button visible. Cards clickable.
  - Deps: E1-4, E1-6

- [x] **E1-8**: Build the recipe detail view in frontend/js/recipes.js (extending it). When a recipe card is clicked, open a modal showing the full recipe: title, description, category badge, prep time, cook time, total time, servings, tags as chips, ingredients list (each showing quantity + unit + item with grocery section label), and instructions (preserving newlines for numbered steps). Two action buttons: Edit (opens create/edit form modal pre-filled -- wired to E1-9) and Delete (browser confirm dialog, on confirm calls DELETE /api/recipes/{id}, closes modal, refreshes collection). Back button closes modal. Detail view fetches GET /api/recipes/{id} for complete data including ingredients.
  - Value: Enables the cook to view all details of a recipe including full ingredient list before deciding to cook, edit, or delete it -- the read step in the CRUD lifecycle
  - Acceptance: Clicking a recipe card opens detail modal. Shows: title, description, category, prep time, cook time, servings, tags, ingredients (quantity + unit + item), instructions. Edit button opens form modal pre-filled. Delete button shows confirm(); confirming deletes via API and returns to collection where recipe is gone. Back button closes modal. All seed recipe data displays correctly (e.g. Classic Oatmeal shows 1 cup rolled oats, 2 cup milk, 1 tbsp honey).
  - Deps: E1-7

- [x] **E1-9**: Build the recipe create/edit form modal in frontend/js/recipes.js (extending it). Modal overlay with form containing: title (text, required), description (textarea), category (dropdown: breakfast/lunch/dinner/snack/dessert, required), prep_time_minutes (number), cook_time_minutes (number), servings (number), instructions (textarea), tags (text, comma-separated). Dynamic ingredients section: container with ingredient rows, each row having quantity (number), unit (text/dropdown), item (text), grocery_section (dropdown: produce/meat/dairy/pantry/frozen/other). Add Ingredient button appends new empty row. Each row has Remove (X) button (minimum 1 row). Two modes: (a) Create via Add Recipe button -- empty fields, POST /api/recipes. (b) Edit via detail view Edit button -- pre-populated from recipe data including all ingredient rows, PUT /api/recipes/{id}. On success, modal closes and collection refreshes. Validation: title and category required; at least one ingredient with item filled.
  - Value: Enables the cook to create new recipes with structured ingredient data and edit existing ones -- the write step in the CRUD lifecycle that populates the recipe collection
  - Acceptance: Add Recipe opens modal with empty form. All fields present: title, description, category dropdown, times, servings, instructions, tags. Ingredients section shows one empty row with qty/unit/item/section fields. Add Ingredient appends row. Remove (X) removes row (cant remove last). Create: fill title=Test Recipe, category=dinner, one ingredient (2, cups, rice, pantry), submit creates via POST. Modal closes, grid refreshes with new card. Edit: opens same modal pre-filled, modify title, submit via PUT updates recipe. Collection shows updated title.
  - Deps: E1-7


## Verification

- [x] **E1-10**: End-to-end verification of full recipe lifecycle through the UI. (1) Run pytest sprints/recipe-manager/tests/test_api.py and verify all tests pass. Fix any failures. (2) Create or update verification script at sprints/recipe-manager/.loop/verifications/run_all.py that programmatically verifies Epic 1 acceptance criteria: server starts on port 8000, GET /api/recipes returns 5 seed recipes, ingredient search works (search=oats returns results), frontend index.html served with expected DOM structure, CSS and JS files served. Script exits 0 on success, non-zero on failure. (3) Verify via browser evaluation: open localhost:8000, see 5 seed recipe cards, use filters, create a recipe, view detail, edit, delete. Confirm dark theme at 1024px and 768px.
  - Value: Proves the entire Epic 1 value promise end-to-end: a home cook can build, browse, search, and manage their recipe collection through a working dark-themed UI -- not just individual components passing tests in isolation
  - Acceptance: All pytest tests pass (0 failures). Verification script exits 0. Server serves frontend at localhost:8000. 5 seed recipes visible as cards with dark theme. Filter by category shows only matching. Search by ingredient works. Full CRUD lifecycle: create recipe with ingredients, view in grid, open detail, edit, see changes, delete, confirm gone. Layout renders at 1024px and 768px without horizontal scroll.
  - Deps: E1-5, E1-8, E1-9
