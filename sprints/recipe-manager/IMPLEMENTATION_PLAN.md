# Implementation Plan (rendered from state)

Generated: 2026-02-17T21:57:44.431648


## Foundation

- [x] **1.1**: Create project structure with backend/main.py (FastAPI app with CORS, static file mounting for frontend/, configurable PORT via env var defaulting to 8000), backend/requirements.txt (fastapi, uvicorn), and empty frontend/ directory structure (index.html, css/style.css, js/app.js, js/recipes.js, js/planner.js, js/shopping.js). The FastAPI app must serve the frontend at / via StaticFiles mount and expose API routes under /api/. Include startup logic to terminate any existing process on port 8000 before binding.
  - Value: Establishes the runnable application skeleton so all subsequent tasks have a working server to build upon — without this foundation, nothing can be tested or demonstrated
  - Acceptance: Running uvicorn backend.main:app from sprints/recipe-manager/ starts successfully on port 8000. GET http://localhost:8000/ returns the index.html file. GET http://localhost:8000/api/recipes returns an empty JSON list or 200 response (once routes are wired). No port conflict errors.

- [x] **1.2**: Create backend/database.py with SQLite connection management: get_db() function returning a connection to data/recipes.db with foreign keys enabled (PRAGMA foreign_keys=ON), init_db() function that creates ALL tables per PRD Section 2.1 schema: recipes, ingredients, meal_plans, shopping_lists, shopping_items (with all columns, constraints, CASCADE deletes, UNIQUE constraints, and default values). The data/ directory and .db file are auto-created if missing. init_db() is called on app startup. ALSO: on first run when recipes table is empty, insert 5 seed recipes (one per category: breakfast, lunch, dinner, snack, dessert) each with 3-6 ingredients spanning different grocery_sections and units per PRD Section 2.3.
  - Value: Enables ALL persistent data storage (recipes, ingredients, meal plans, shopping lists) and eliminates cold start by providing 5 seed recipes — the user sees a populated app immediately on first visit
  - Acceptance: After server startup, data/recipes.db exists with ALL 5 tables: recipes (11 columns), ingredients (7 columns with FK CASCADE), meal_plans (5 columns with UNIQUE and FK CASCADE), shopping_lists (3 columns), shopping_items (8 columns with FK CASCADE). PRAGMA foreign_keys returns 1. On first startup, GET /api/recipes returns 5 seed recipes spanning all categories with ingredients. On subsequent startup, no duplicate seeds.
  - Deps: 1.1

- [x] **1.3**: Create backend/models.py with Pydantic models for recipe API request/response: IngredientCreate (quantity: float, unit: str, item: str, grocery_section: str with default other), RecipeCreate (title, description, category, prep_time_minutes, cook_time_minutes, servings, instructions, tags, ingredients: list[IngredientCreate]), IngredientResponse (adds id), RecipeResponse (adds id, created_at, updated_at, ingredients: list[IngredientResponse]), RecipeListItem (card-level fields without full ingredients for list endpoint).
  - Value: Provides validated data contracts between frontend and backend, preventing malformed data from corrupting the database
  - Acceptance: Importing models in Python works without errors. RecipeCreate validates required fields (title, category) and rejects missing required fields. IngredientCreate accepts valid grocery_section values. RecipeResponse includes nested ingredients list.
  - Deps: 1.1


## Core

- [x] **1.4**: Create backend/routes/recipes.py with full Recipe CRUD endpoints and query filtering: POST /api/recipes (create recipe with nested ingredients, return 201 with created resource), GET /api/recipes (list all recipes as card-level items with optional query parameter filtering: ?category= exact match, ?tag= partial match within comma-separated tags, ?search= across title, description, and ingredient items via JOIN; all three filters combinable with AND logic), GET /api/recipes/{id} (get single recipe with full ingredients), PUT /api/recipes/{id} (update recipe, replaces ingredients list entirely), DELETE /api/recipes/{id} (delete recipe, cascade removes ingredients and meal plan entries). All endpoints use proper HTTP status codes (201 for create, 404 for not found, 200 for success). Wire the router into main.py.
  - Value: Enables the core recipe management workflow — users can create, read, update, and delete their recipes through the API, which is the foundation for the entire app
  - Acceptance: POST /api/recipes with valid body returns 201 with id. GET /api/recipes returns list including the created recipe. GET /api/recipes/{id} returns recipe with ingredients array. PUT /api/recipes/{id} updates title and replaces ingredients. DELETE /api/recipes/{id} returns 200 and subsequent GET returns 404. GET /api/recipes?category=dinner returns only dinner recipes. GET /api/recipes?search=chicken returns recipes with chicken in title, description, or ingredient items. GET /api/recipes?tag=quick returns recipes tagged quick. GET /api/recipes?category=dinner&search=pasta&tag=quick returns only recipes matching ALL three filters. Empty result set returns [].
  - Deps: 1.2, 1.3

- [x] **1.7**: Write pytest integration tests in tests/test_api.py for all recipe API endpoints: test create recipe with ingredients (201 response, verify fields), test get recipe list (200, array), test get single recipe with ingredients (200, nested), test update recipe and replace ingredients (200, verify changes), test delete recipe (200, subsequent get returns 404), test cascading delete removes ingredients. Test all filter combinations: category filter, tag filter, search by title, search by ingredient name, combined filters. Test seed data: fresh DB has 5 recipes spanning all 5 categories, each with ingredients. Use httpx.AsyncClient with FastAPI TestClient and a fresh temp DB per test session.
  - Value: Provides automated verification that the recipe API works correctly, catching regressions before they reach the user
  - Acceptance: All tests pass with pytest. Tests cover: CRUD operations (create, read, update, delete), filter operations (category, tag, search, combined), seed data verification (5 recipes on fresh DB), cascade delete (ingredients removed when recipe deleted). At least 12 test functions.
  - Deps: 1.4

- [ ] **E1-1**: Fix ingredient search in backend/routes/recipes.py list_recipes(). The current SQL query at lines 79-81 only searches title and description fields. Must add LEFT JOIN ingredients i ON i.recipe_id = r.id to the FROM clause, add OR i.item LIKE ? to the WHERE clause search condition, and change SELECT r.* to SELECT DISTINCT r.* to prevent duplicate results when multiple ingredients match. This is a targeted fix to ~5 lines of SQL in one function.
  - Value: Enables the cook to search recipes by ingredient name (e.g. searching chicken finds all chicken recipes) -- a core Epic 1 completion criterion that the existing test suite already validates
  - Acceptance: GET /api/recipes?search=oats returns Classic Oatmeal (matched via ingredient rolled oats). GET /api/recipes?search=broccoli returns Beef Stir Fry (via ingredient, not title/description). GET /api/recipes?search=chicken returns Grilled Chicken Salad. Combined filters still work: GET /api/recipes?category=dinner&search=broccoli returns only Beef Stir Fry. No duplicate recipes in results. The existing test_search_by_ingredient_distinct_term test in test_api.py passes (currently the 1 failing test). All 62/62 tests pass.

- [ ] **E1-2**: Build the SPA shell and professional dark theme. Rewrite frontend/index.html with semantic HTML structure: top navigation bar with three tabs (Recipes, Meal Plan, Shopping List), main content area with id=app for dynamic content. Create frontend/css/style.css with a professional dark theme: dark background (#1a1a2e or similar), light text (#eee), accent color for interactive elements, styled nav bar with active tab highlighting, card component styles, modal overlay styles, form input styles, button styles (primary/danger/ghost variants), responsive grid breakpoints for 1024px and 768px widths, CSS custom properties for theme colors. Create frontend/js/app.js with: hash-based SPA router defaulting to #recipes, route change listener that calls view-specific render functions, active tab state management, shared API fetch wrapper (async function that handles JSON request/response and error display), DOM helper utilities for creating elements. The Recipes tab must be active by default on page load.
  - Value: Provides the visual foundation and navigation framework for the entire app -- the user sees a polished dark-themed interface and can navigate between views, which is the entry point to ALL subsequent user interactions
  - Acceptance: Opening localhost:8000 shows a dark-themed page with visible nav bar containing three labeled tabs (Recipes, Meal Plan, Shopping List). Recipes tab is highlighted/active by default. Clicking each tab changes the URL hash (#recipes, #planner, #shopping) and shows different content areas. The active tab visual indicator follows clicks. Dark theme has dark background, light text, and accent colors on buttons/links. Layout renders cleanly at both 1024px and 768px widths without horizontal scroll. No console errors in browser. CSS file defines at least: nav styling, card grid, modal overlay, form inputs, button variants, responsive breakpoints.

- [ ] **E1-3**: Build the recipe collection view with card grid and filter bar in frontend/js/recipes.js. This file implements the #recipes view. (1) Filter bar at top: search text input with debounced keyup (300ms) calling GET /api/recipes?search=, category dropdown (All, breakfast, lunch, dinner, snack, dessert) calling GET /api/recipes?category=, tag filter input calling GET /api/recipes?tag=. All three filters combine: changing any filter re-fetches with all current filter values as query params. (2) Card grid below filters: responsive CSS grid of recipe cards. Each card shows: recipe title as heading, category badge (colored pill), total time (prep + cook displayed as e.g. 35 min), and tag chips (each tag as a small pill). Cards are clickable -- clicking navigates to recipe detail view (task E1-4). (3) Add Recipe button (prominent, in filter bar area) that opens the create form modal (task E1-5). On initial load of #recipes view, fetch GET /api/recipes with no filters to show all recipes. The 5 seed recipes must appear as cards immediately.
  - Value: Enables the cook to browse their recipe collection at a glance and quickly find specific recipes using search and filters -- the primary entry point to the Recipe Collection workflow
  - Acceptance: Navigating to localhost:8000 (or #recipes) shows a filter bar with search input, category dropdown, and tag filter input. Below it, 5 seed recipe cards are displayed in a responsive grid. Each card shows title, category badge (colored), total prep+cook time, and tag chips. Typing chicken in search input (after 300ms debounce) re-fetches and shows only matching recipes. Selecting dinner from category dropdown shows only dinner recipes. Combining search=broccoli with category=dinner shows only Beef Stir Fry. Clearing all filters shows all 5 recipes again. An Add Recipe button is visible. Cards are clickable (click handler registered, navigation to detail view).
  - Deps: E1-1, E1-2

- [ ] **E1-4**: Build the recipe detail view in frontend/js/recipes.js (same file as E1-3, extending it). When a recipe card is clicked, the collection view is replaced by a detail view showing the full recipe: title, description, category badge, prep time, cook time, total time, servings, tags as chips, ingredients list (each showing quantity + unit + item with grocery section label), and instructions text (preserving newlines for numbered steps). Two action buttons: Edit (opens the create/edit form modal pre-filled with this recipe data -- wired to task E1-5) and Delete (shows browser confirm dialog, on confirm calls DELETE /api/recipes/{id}, then navigates back to collection view). A Back button/link returns to the collection view. The detail view fetches from GET /api/recipes/{id} to ensure complete data including ingredients.
  - Value: Enables the cook to view all details of a recipe including the full ingredient list before deciding to cook, edit, or delete it -- the read step in the CRUD lifecycle
  - Acceptance: Clicking a recipe card in the collection grid transitions to a detail view. Detail view shows: title, description, category, prep time, cook time, servings, tags, numbered/listed ingredients (quantity + unit + item), and instructions. Edit button is present and clickable (opens form modal). Delete button shows confirm() dialog; confirming deletes the recipe via API and returns to collection view where recipe is gone. Back button returns to collection grid. All fields populated correctly from seed recipe data (e.g. Classic Oatmeal shows 1 cup rolled oats, 2 cup milk, 1 tbsp honey).
  - Deps: E1-3

- [ ] **E1-5**: Build the recipe create/edit form modal in frontend/js/recipes.js (same file, extending it). A modal overlay containing a form with all recipe fields: title (text, required), description (textarea), category (dropdown: breakfast/lunch/dinner/snack/dessert, required), prep_time_minutes (number), cook_time_minutes (number), servings (number), instructions (textarea), tags (text, comma-separated). Dynamic ingredients section: a container with ingredient rows, each row having quantity (number input), unit (text input or dropdown with common units), item (text input), grocery_section (dropdown: produce/meat/dairy/pantry/frozen/other). An Add Ingredient button appends a new empty row. Each row has a Remove button (X) that removes that row (minimum 1 row). The form opens in two modes: (a) Create mode via the Add Recipe button -- all fields empty, submits POST /api/recipes. (b) Edit mode via the detail view Edit button -- all fields pre-populated from the recipe data including all ingredient rows, submits PUT /api/recipes/{id}. On successful submit, the modal closes and the collection view refreshes showing the new/updated recipe. Validation: title and category are required; at least one ingredient row must have item filled.
  - Value: Enables the cook to create new recipes with structured ingredient data and edit existing ones -- the write step in the CRUD lifecycle that populates the entire recipe collection
  - Acceptance: Clicking Add Recipe opens a modal with empty form. Form has all fields: title, description, category dropdown, prep/cook time, servings, instructions, tags. Ingredients section shows one empty row with quantity/unit/item/section fields. Add Ingredient button appends a new row. Remove button (X) on each row removes it (cannot remove last row). Filling in title=Test Recipe, category=dinner, one ingredient (2, cups, rice, pantry) and submitting creates the recipe via POST API. Modal closes, collection grid refreshes showing the new recipe card. Clicking Edit on a recipe detail view opens the same modal pre-filled with all data including ingredient rows. Modifying title and submitting via PUT updates the recipe. Collection view shows updated title.
  - Deps: E1-3


## Verification

- [ ] **E1-6**: Ensure all 62 pytest integration tests pass and the full recipe lifecycle works end-to-end through the UI. (1) Run pytest sprints/recipe-manager/tests/test_api.py and verify all 62 tests pass (including the ingredient search test that was previously failing due to VRC-1). Fix any test failures by correcting backend code or test expectations. (2) Create or update the verification script at sprints/recipe-manager/.loop/verifications/run_all.py that programmatically verifies key Epic 1 acceptance criteria: server starts on port 8000, GET /api/recipes returns 5 seed recipes, ingredient search works (search=oats returns results), frontend index.html is served with expected DOM structure (nav, content area), CSS and JS files are served. The script must exit 0 on success, non-zero on failure. (3) Manually verify via browser or automated check: open localhost:8000, see 5 seed recipe cards, use filters, create a recipe, view detail, edit, delete, confirm dark theme at 1024px and 768px.
  - Value: Proves the entire Epic 1 value promise end-to-end: a home cook can build, browse, search, and manage their recipe collection through a working dark-themed UI -- not just individual components passing tests in isolation
  - Acceptance: All 62 pytest tests pass (0 failures, 0 errors). Verification script at .loop/verifications/run_all.py exits 0. Server starts and serves frontend at localhost:8000. 5 seed recipes visible as cards with dark theme. Filter by category shows only matching. Search by ingredient returns matching (oats finds Oatmeal, broccoli finds Stir Fry). Full CRUD lifecycle works: create recipe with ingredients, view in grid, open detail, edit title, see change in grid, delete, confirm gone. Layout renders at 1024px and 768px without horizontal scroll or overlapping elements.
  - Deps: E1-1, E1-4, E1-5
