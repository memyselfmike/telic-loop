# Implementation Plan (rendered from state)

Generated: 2026-02-18T00:07:15.265690


## Foundation

- [x] **E1-1**: Set up project structure with backend/main.py (FastAPI app with CORS, static file mounting for frontend/, configurable PORT via env var defaulting to 8000), backend/requirements.txt (fastapi, uvicorn), and frontend directory structure (index.html, css/style.css, js/app.js, js/recipes.js, js/planner.js, js/shopping.js). FastAPI serves frontend at / via StaticFiles mount and exposes API routes under /api/.
  - Value: Establishes the runnable application skeleton so all subsequent tasks have a working server to build upon -- without this foundation, nothing can be tested or demonstrated
  - Acceptance: Running uvicorn backend.main:app from sprints/recipe-manager/ starts on port 8000. GET http://localhost:8000/ returns index.html. GET http://localhost:8000/api/recipes returns 200 response. No port conflict errors.

- [x] **E1-2**: Create backend/database.py with SQLite connection management: get_db() function returning a connection to data/recipes.db with foreign keys enabled (PRAGMA foreign_keys=ON), init_db() function that creates recipes table (id, title, description, category, prep_time_minutes, cook_time_minutes, servings, instructions, tags, created_at, updated_at) and ingredients table (id, recipe_id FK CASCADE, quantity, unit, item, grocery_section, sort_order). Data directory and .db file auto-created if missing. init_db() called on app startup. On first run when recipes table is empty, insert 5 seed recipes (one per category: breakfast, lunch, dinner, snack, dessert) each with 3-6 ingredients spanning different grocery_sections and units per PRD Section 2.3.
  - Value: Enables ALL persistent data storage for recipes and ingredients, and eliminates cold start by providing 5 seed recipes -- the user sees a populated app immediately on first visit
  - Acceptance: After server startup, data/recipes.db exists with recipes (11 columns) and ingredients (7 columns with FK CASCADE) tables. PRAGMA foreign_keys returns 1. On first startup, GET /api/recipes returns 5 seed recipes spanning all categories with ingredients. On subsequent startup, no duplicate seeds.
  - Deps: E1-1

- [x] **E1-3**: Create backend/models.py with Pydantic v2 models for recipe API request/response: IngredientCreate (quantity: float, unit: str, item: str, grocery_section: str with default other), RecipeCreate (title, description, category, prep_time_minutes, cook_time_minutes, servings, instructions, tags, ingredients: list[IngredientCreate]), IngredientResponse (adds id, sort_order), RecipeResponse (adds id, created_at, updated_at, ingredients: list[IngredientResponse]), RecipeListItem (card-level fields: id, title, category, prep_time_minutes, cook_time_minutes, tags -- without full ingredients for efficient list endpoint).
  - Value: Provides validated data contracts between frontend and backend, preventing malformed data from corrupting the database and ensuring consistent API responses
  - Acceptance: Importing models in Python works without errors. RecipeCreate validates required fields (title, category) and rejects missing required fields. IngredientCreate accepts valid grocery_section values. RecipeResponse includes nested ingredients list. RecipeListItem excludes ingredients for card-level use.
  - Deps: E1-1


## Core

- [x] **E1-4**: Create backend/routes/recipes.py with full Recipe CRUD endpoints and query filtering: POST /api/recipes (create recipe with nested ingredients, return 201), GET /api/recipes (list recipes with optional ?category= exact match, ?tag= partial match in comma-separated tags, ?search= across title, description, AND ingredient items via LEFT JOIN with SELECT DISTINCT; all three combinable with AND logic), GET /api/recipes/{id} (single recipe with full ingredients), PUT /api/recipes/{id} (update recipe, replace ingredients list entirely), DELETE /api/recipes/{id} (cascade removes ingredients). Wire router into main.py. All endpoints use proper HTTP status codes (201 create, 404 not found, 200 success).
  - Value: Enables the core recipe management workflow -- users can create, read, update, delete, search, and filter their recipes through the API, which is the data backbone for the entire app
  - Acceptance: POST /api/recipes returns 201 with id. GET /api/recipes returns list. GET /api/recipes/{id} returns recipe with ingredients. PUT updates and replaces ingredients. DELETE returns 200, subsequent GET returns 404. Category filter returns only matching. Search by ingredient name works (search=oats returns Classic Oatmeal via JOIN). Tag filter works. Combined filters (category=dinner&search=pasta&tag=quick) returns only recipes matching ALL. Empty result returns [].
  - Deps: E1-2, E1-3

- [x] **E1-5**: Write pytest integration tests in tests/test_api.py for all recipe API endpoints: test create recipe with ingredients (201, verify fields), test get recipe list (200, array), test get single recipe with ingredients (200, nested), test update recipe and replace ingredients (200, verify changes), test delete recipe (200, subsequent GET 404), test cascading delete removes ingredients. Test all filter combinations: category filter, tag filter, search by title, search by ingredient name (via JOIN), combined filters. Test seed data: fresh DB has 5 recipes spanning all 5 categories with ingredients. Use httpx.AsyncClient with FastAPI TestClient and a fresh temp DB per test session.
  - Value: Provides automated verification that the recipe API works correctly across all CRUD operations and filter combinations, catching regressions before they reach the user
  - Acceptance: All tests pass with pytest. Tests cover: CRUD operations (create, read, update, delete), filter operations (category, tag, search, combined), seed data verification (5 recipes on fresh DB), cascade delete (ingredients removed when recipe deleted), ingredient search via JOIN. At least 15 test functions.
  - Deps: E1-4

- [x] **E1-6**: Build the SPA shell and professional dark theme. Rewrite frontend/index.html with semantic HTML: top navigation bar with three tabs (Recipes, Meal Plan, Shopping List), main content area with id=app. Create frontend/css/style.css with professional dark theme: dark background (#1a1a2e or similar), light text (#eee), accent color for interactive elements, styled nav bar with active tab highlighting, card component styles, modal overlay styles, form input styles, button styles (primary/danger/ghost variants), responsive grid breakpoints for 1024px and 768px. Create frontend/js/app.js with: hash-based SPA router defaulting to #recipes, route change listener calling view-specific render functions, active tab state management, shared async API fetch wrapper with error handling, DOM helper utilities. Recipes tab active by default on load.
  - Value: Provides the visual foundation and navigation framework for the entire app -- the user sees a polished dark-themed interface and can navigate between views, the entry point to ALL user interactions
  - Acceptance: Opening localhost:8000 shows dark-themed page with nav bar containing three labeled tabs. Recipes tab highlighted/active by default. Clicking tabs changes URL hash (#recipes, #planner, #shopping) and shows different content. Dark theme has dark background, light text, accent colors. Layout renders cleanly at 1024px and 768px without horizontal scroll. No console errors. CSS defines: nav styling, card grid, modal overlay, form inputs, button variants, responsive breakpoints.

- [x] **E1-7**: Build the recipe collection view with card grid and filter bar in frontend/js/recipes.js. (1) Filter bar at top: search text input with debounced keyup (300ms), category dropdown (All/breakfast/lunch/dinner/snack/dessert), tag filter input. All three filters combine: changing any re-fetches GET /api/recipes with all current filter values as query params. (2) Card grid: responsive CSS grid of recipe cards, each showing title as heading, category badge (colored pill), total time (prep+cook as e.g. 35 min), tag chips. Cards clickable -- click opens recipe detail view (E1-8). (3) Add Recipe button in filter bar area opens create form modal (E1-9). On initial load of #recipes view, fetch GET /api/recipes with no filters to show all. 5 seed recipes must appear as cards immediately.
  - Value: Enables the cook to browse their recipe collection at a glance and quickly find specific recipes using combinable search and filters -- the primary entry point to the Recipe Collection workflow
  - Acceptance: Navigating to localhost:8000 shows filter bar with search input, category dropdown, tag filter. Below it, 5 seed recipe cards in responsive grid. Each card shows title, colored category badge, total time, tag chips. Typing in search (after 300ms debounce) re-fetches matching recipes. Category dropdown filters. Combined filters work (category=dinner + search=broccoli shows only Beef Stir Fry). Clearing filters shows all 5. Add Recipe button visible. Cards clickable.
  - Deps: E1-4, E1-6

- [x] **E1-8**: Build the recipe detail view in frontend/js/recipes.js (extending it). When a recipe card is clicked, open a modal showing the full recipe: title, description, category badge, prep time, cook time, total time, servings, tags as chips, ingredients list (each showing quantity + unit + item with grocery section label), and instructions (preserving newlines for numbered steps). Two action buttons: Edit (opens create/edit form modal pre-filled -- wired to E1-9) and Delete (browser confirm dialog, on confirm calls DELETE /api/recipes/{id}, closes modal, refreshes collection). Back button closes modal. Detail view fetches GET /api/recipes/{id} for complete data including ingredients.
  - Value: Enables the cook to view all details of a recipe including full ingredient list before deciding to cook, edit, or delete it -- the read step in the CRUD lifecycle
  - Acceptance: Clicking a recipe card opens detail modal. Shows: title, description, category, prep time, cook time, servings, tags, ingredients (quantity + unit + item), instructions. Edit button opens form modal pre-filled. Delete button shows confirm(); confirming deletes via API and returns to collection where recipe is gone. Back button closes modal. All seed recipe data displays correctly (e.g. Classic Oatmeal shows 1 cup rolled oats, 2 cup milk, 1 tbsp honey).
  - Deps: E1-7

- [x] **E1-9**: Build the recipe create/edit form modal in frontend/js/recipes.js (extending it). Modal overlay with form containing: title (text, required), description (textarea), category (dropdown: breakfast/lunch/dinner/snack/dessert, required), prep_time_minutes (number), cook_time_minutes (number), servings (number), instructions (textarea), tags (text, comma-separated). Dynamic ingredients section: container with ingredient rows, each row having quantity (number), unit (text/dropdown), item (text), grocery_section (dropdown: produce/meat/dairy/pantry/frozen/other). Add Ingredient button appends new empty row. Each row has Remove (X) button (minimum 1 row). Two modes: (a) Create via Add Recipe button -- empty fields, POST /api/recipes. (b) Edit via detail view Edit button -- pre-populated from recipe data including all ingredient rows, PUT /api/recipes/{id}. On success, modal closes and collection refreshes. Validation: title and category required; at least one ingredient with item filled.
  - Value: Enables the cook to create new recipes with structured ingredient data and edit existing ones -- the write step in the CRUD lifecycle that populates the recipe collection
  - Acceptance: Add Recipe opens modal with empty form. All fields present: title, description, category dropdown, times, servings, instructions, tags. Ingredients section shows one empty row with qty/unit/item/section fields. Add Ingredient appends row. Remove (X) removes row (cant remove last). Create: fill title=Test Recipe, category=dinner, one ingredient (2, cups, rice, pantry), submit creates via POST. Modal closes, grid refreshes with new card. Edit: opens same modal pre-filled, modify title, submit via PUT updates recipe. Collection shows updated title.
  - Deps: E1-7

- [ ] **E2-1**: Build the weekly meal planner grid view in planner.js: render a 7-column (Mon-Sun) x 4-row (breakfast, lunch, dinner, snack) HTML table using the existing CSS classes (.meal-table, .meal-cell, .meal-row-label, etc.). On load, calculate the current week start (Monday ISO date), call GET /api/meals?week={weekStart} to fetch assigned meals, and populate cells — empty cells show a "+" add button (.meal-cell-add), filled cells show recipe title (.meal-cell-title) and time (.meal-cell-time). Include a day header row (th per day: Mon-Sun) and a day total summary row (.day-total-row) showing total prep+cook time per column. Use window.App.el() for DOM construction and window.App.apiFetch() for API calls.
  - Value: Enables the user to see the weekly meal grid at a glance — the core visual structure that makes meal planning possible. Without this grid, no planner interaction can happen.
  - Acceptance: Navigating to #planner renders a 7-column x 4-row meal table. GET /api/meals is called with the current week start. Empty cells show "+" icons. The day summary row shows 0m for days with no meals. No JS errors in console.

- [ ] **E2-2**: Implement week navigation controls in planner.js: add a navigation bar (.planner-week-nav) above the grid with Previous/Next week arrow buttons and a "This Week" button. Clicking Previous subtracts 7 days from the current weekStart, clicking Next adds 7 days, and "This Week" resets to the current Monday. Display the week range as a label (e.g., "Feb 16 – Feb 22, 2026") in a .week-label element. Each navigation action recalculates weekStart, calls GET /api/meals?week={newWeekStart}, and re-renders the grid cells and day totals. Persist the current weekStart in a module-level variable so re-renders maintain position.
  - Value: Enables the user to plan ahead or review past weeks — without navigation, the planner is locked to a single week and cannot support weekly meal prep workflow.
  - Acceptance: Clicking Previous/Next arrows changes the week label and re-fetches meal data for the new week. Clicking "This Week" returns to the current week. Grid updates correctly with each navigation. Multiple rapid clicks do not cause stale data rendering.
  - Deps: E2-1

- [ ] **E2-3**: Implement the recipe picker modal in planner.js: when the user clicks a "+" (empty cell) in the meal grid, open a modal (using window.App.openModal) titled "Pick a Recipe" containing a search input (.picker-search) and a scrollable list (.picker-list) of all recipes fetched from GET /api/recipes. Each list item (.picker-item) shows recipe title (.picker-item-title) and time + category (.picker-item-meta). The search input filters the list in real-time by title (case-insensitive substring match). Clicking a recipe item calls PUT /api/meals with {week_start, day_of_week, meal_slot, recipe_id}, closes the modal, and updates the clicked cell to show the recipe title and time without full page re-render.
  - Value: Enables the user to assign recipes to meal slots — the primary action of the meal planner. Without the picker, slots cannot be filled and the planner is read-only.
  - Acceptance: Clicking "+" on an empty cell opens a modal with all recipes listed. Typing in the search box filters recipes in real-time. Clicking a recipe assigns it to the slot (PUT /api/meals returns 200), the modal closes, and the cell now shows the recipe title and prep+cook time. Toast notification confirms assignment.
  - Deps: E2-1

- [ ] **E2-4**: Implement slot interactions for assigned recipe cells in planner.js: when the user clicks a cell that already has a recipe assigned, show an action popup or context menu with three options: (1) "View Recipe" — navigates to #recipes and could open recipe detail (or shows recipe info in a modal), (2) "Swap" — opens the recipe picker modal to replace the current recipe in this slot (reuses E2-3 picker, PUT /api/meals upserts), (3) "Clear" — calls DELETE /api/meals/{mealId} and updates the cell back to the empty "+" state. Additionally, show a remove button (.meal-cell-remove) on hover that directly clears the slot without the menu for quick removal. After any slot change, recalculate and update the day total row for that column.
  - Value: Enables the user to manage and adjust their meal plan — swap recipes between slots, clear mistakes, and review recipes directly from the planner view.
  - Acceptance: Clicking an assigned cell shows View/Swap/Clear options. "Swap" opens the picker and replaces the recipe. "Clear" removes the assignment and shows "+" again. The hover X button clears the slot. Day totals update after every slot change. DELETE returns 204 and the cell reverts to empty state.
  - Deps: E2-3

- [ ] **E2-5**: Implement copy-to-slots (meal prep) workflow in planner.js: add a "Copy to slots..." option in the assigned-recipe action menu (from E2-4). When selected, open a modal showing a checkbox grid of all 28 slots (7 days x 4 meals) where the user can select multiple target slots. Pre-check the current slot. A "Copy" button fires one PUT /api/meals call per selected slot (sequentially or with Promise.all), then refreshes the grid. This enables the PRD meal-prep scenario: same lunch Monday-Friday. Show a toast summarizing how many slots were filled (e.g., "Copied to 5 slots"). Handle errors gracefully — if some PUTs fail, report which succeeded.
  - Value: Enables the meal prep workflow — the user assigns the same recipe to multiple day/slot combinations in one action, saving significant time versus clicking each slot individually.
  - Acceptance: User assigns a recipe to Monday lunch, clicks it, selects "Copy to slots...", checks Tue-Fri lunch, clicks Copy. All 5 PUT calls succeed and all 5 lunch cells show the recipe. Toast confirms "Copied to 5 slots". Day totals update for each affected day.
  - Deps: E2-4


## Verification

- [x] **E1-10**: End-to-end verification of full recipe lifecycle through the UI. (1) Run pytest sprints/recipe-manager/tests/test_api.py and verify all tests pass. Fix any failures. (2) Create or update verification script at sprints/recipe-manager/.loop/verifications/run_all.py that programmatically verifies Epic 1 acceptance criteria: server starts on port 8000, GET /api/recipes returns 5 seed recipes, ingredient search works (search=oats returns results), frontend index.html served with expected DOM structure, CSS and JS files served. Script exits 0 on success, non-zero on failure. (3) Verify via browser evaluation: open localhost:8000, see 5 seed recipe cards, use filters, create a recipe, view detail, edit, delete. Confirm dark theme at 1024px and 768px.
  - Value: Proves the entire Epic 1 value promise end-to-end: a home cook can build, browse, search, and manage their recipe collection through a working dark-themed UI -- not just individual components passing tests in isolation
  - Acceptance: All pytest tests pass (0 failures). Verification script exits 0. Server serves frontend at localhost:8000. 5 seed recipes visible as cards with dark theme. Filter by category shows only matching. Search by ingredient works. Full CRUD lifecycle: create recipe with ingredients, view in grid, open detail, edit, see changes, delete, confirm gone. Layout renders at 1024px and 768px without horizontal scroll.
  - Deps: E1-5, E1-8, E1-9


## Integration

- [ ] **E2-6**: Verify meal plan persistence and cascade delete behavior in planner.js integration: (1) Persistence — assign recipes to several slots, navigate to #recipes and back to #planner, confirm slots still show assigned recipes (data fetched fresh from API each time). Navigate between weeks and back, confirm data persists. (2) Cascade delete — assign a recipe to a planner slot, switch to #recipes, delete that recipe, switch back to #planner, confirm the slot is now empty (the meal_plans row was cascade-deleted in SQLite). Ensure no errors occur when rendering a week that had cascade-deleted entries. (3) Day totals accuracy — assign multiple recipes to one day, verify the day total row sums prep+cook time correctly.
  - Value: Proves the planner delivers trustworthy data — meals persist across navigation and page reloads, and cascade deletes keep the planner consistent when recipes are removed from the collection.
  - Acceptance: Assigned meals survive navigation between tabs and between weeks. Deleting a recipe from the collection clears it from all planner slots. Day total row accurately sums total_time values for all recipes in each column. No stale data or JS errors after cascade deletes.
  - Deps: E2-4
