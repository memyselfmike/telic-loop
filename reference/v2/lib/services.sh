#!/bin/bash
# Loop V2 Service Startup - Vision detection and service management
#
# Dependencies: lib/ui.sh (for print_status), lib/prompts.sh (for run_prompt)
# Requires: VISION_FILE, PLAN_FILE, BLOCKERS_FILE
#
# SERVICE DISCOVERY PRIORITY:
# 1. {SPRINT_DIR}/services.yaml - Explicit sprint service definitions
# 2. docker-compose.yml         - Docker Compose orchestration
# 3. VISION.md + package.json   - Legacy npm-based detection
#
# For Docker or complex services, use services-v2.sh functions.

# Source v2 services if available
if [[ -f "$LOOP_ROOT/lib/services-v2.sh" ]]; then
    source "$LOOP_ROOT/lib/services-v2.sh"
fi

# Track service fix attempts to prevent infinite loops
declare -A SERVICE_FIX_ATTEMPTS

# Track total service startup failures across the session
TOTAL_SERVICE_FAILURES=${TOTAL_SERVICE_FAILURES:-0}
MAX_TOTAL_SERVICE_FAILURES=10

# ═══════════════════════════════════════════════════════════════════════════
# ORCHESTRATION DETECTION
# ═══════════════════════════════════════════════════════════════════════════

# Should we use v2 (docker/services.yaml) or legacy (npm scripts)?
should_use_services_v2() {
    # Explicit override
    if [[ "$LOOP_SERVICES_VERSION" == "v1" ]]; then
        return 1
    elif [[ "$LOOP_SERVICES_VERSION" == "v2" ]]; then
        return 0
    fi

    # Auto-detect: use v2 if docker-compose or services.yaml exists
    [[ -f "docker-compose.yml" ]] || \
    [[ -f "docker-compose.yaml" ]] || \
    [[ -f "compose.yml" ]] || \
    [[ -f "compose.yaml" ]] || \
    [[ -f "$SPRINT_DIR/services.yaml" ]] || \
    [[ -f "$SPRINT_DIR/services.yml" ]]
}

# ═══════════════════════════════════════════════════════════════════════════
# LEGACY VISION-BASED DETECTION (v1)
# ═══════════════════════════════════════════════════════════════════════════

# Detect what VISION requires
vision_requires_browser() {
    grep -qiE "browser|automation|scraping|selenium|playwright|cdp|chrome|headless" "$VISION_FILE" 2>/dev/null
}

vision_requires_backend() {
    grep -qiE "api|backend|server|database|queue" "$VISION_FILE" 2>/dev/null
}

vision_requires_frontend() {
    grep -qiE "dashboard|ui|frontend|web|interface" "$VISION_FILE" 2>/dev/null
}

# Find available scripts in package.json
find_script() {
    local pattern="$1"
    grep -oE "\"${pattern}[^\"]*\"" package.json 2>/dev/null | head -1 | tr -d '"'
}

# Check if a service implementation task already exists
service_task_exists() {
    local service_name="$1"
    if [[ -f "$PLAN_FILE" ]]; then
        grep -qiE "(implement|create|add|fix).*$service_name.*(startup|server|service)" "$PLAN_FILE" 2>/dev/null
    else
        return 1
    fi
}

# Create an implementation task for a missing/broken service
create_service_impl_task() {
    local service_name="$1"
    local port="$2"
    local error_type="$3"  # NOT_IMPLEMENTED or STARTUP_BUG

    # Check if task already exists
    if service_task_exists "$service_name"; then
        print_status "info" "Implementation task for $service_name already exists"
        return 0
    fi

    local task_id="SVC-$(date +%s | tail -c 5)"

    print_status "info" "Creating implementation task for $service_name..."

    # Add task to implementation plan
    if [[ "$error_type" == "NOT_IMPLEMENTED" ]]; then
        cat >> "$PLAN_FILE" << EOF

## Service Implementation (Auto-Generated by Loop)

- [ ] **$task_id**: Implement $service_name server
  - **Value**: Required for application to function
  - **Context**: Service startup failed - no implementation found
  - **Acceptance Criteria**:
    - \`npm run dev:api\` (or equivalent) starts $service_name on port $port
    - Health check endpoint responds at http://localhost:$port/api/health
    - Graceful error handling for missing dependencies
  - **Files**: Create src/server.ts or equivalent entry point
EOF
    else
        cat >> "$PLAN_FILE" << EOF

## Service Bug Fix (Auto-Generated by Loop)

- [ ] **$task_id**: Fix $service_name startup bug
  - **Value**: Required for application to function
  - **Context**: Service exists but fails to start - check /tmp/loop-backend.log
  - **Acceptance Criteria**:
    - \`npm run dev:api\` (or equivalent) starts successfully
    - Health check endpoint responds at http://localhost:$port/api/health
    - No errors in startup log
  - **Debug Info**: Check /tmp/loop-backend.log for error details
EOF
    fi

    print_status "ok" "Created task $task_id for $service_name"
    auto_commit "loop-v2($SPRINT): Created $service_name implementation task"
}

# Diagnose and fix a service startup failure
# Returns 0 if fixed (retry), 1 if needs implementation task, 2 if external blocker
diagnose_and_fix_service() {
    local service_name="$1"
    local log_file="$2"
    local port="$3"
    local max_attempts=3

    # Track attempts to prevent infinite loops
    local attempts=${SERVICE_FIX_ATTEMPTS[$service_name]:-0}
    ((attempts++)) || true  # Prevent set -e exit when attempts was 0
    SERVICE_FIX_ATTEMPTS[$service_name]=$attempts

    if [[ $attempts -gt $max_attempts ]]; then
        print_status "error" "$service_name: Max fix attempts ($max_attempts) reached"
        # Create a task so next loop iteration can address it
        create_service_impl_task "$service_name" "$port" "STARTUP_BUG"
        return 1
    fi

    print_status "warn" "$service_name failed to start (attempt $attempts/$max_attempts)"
    print_status "info" "Diagnosing startup failure..."

    # Check if log file exists and has content
    if [[ ! -f "$log_file" ]] || [[ ! -s "$log_file" ]]; then
        print_status "warn" "No log file or empty log - service may not be implemented"
        create_service_impl_task "$service_name" "$port" "NOT_IMPLEMENTED"
        return 1
    fi

    # Quick check for common issues before spawning agent
    local log_content=$(tail -100 "$log_file" 2>/dev/null)

    # Check for "script not found" type errors (not implemented)
    if echo "$log_content" | grep -qE "npm ERR! missing script|not found|ENOENT.*script"; then
        print_status "warn" "$service_name script not found - creating implementation task"
        create_service_impl_task "$service_name" "$port" "NOT_IMPLEMENTED"
        return 1
    fi

    # Check for port already in use
    if echo "$log_content" | grep -q "EADDRINUSE"; then
        print_status "info" "Port $port already in use - killing existing process"
        if command -v lsof &> /dev/null; then
            local pid=$(lsof -t -i:$port 2>/dev/null)
            if [[ -n "$pid" ]]; then
                kill -9 $pid 2>/dev/null || true
                sleep 1
                return 0  # Retry
            fi
        elif command -v netstat &> /dev/null; then
            # Windows/fallback
            local pid=$(netstat -ano | grep ":$port " | grep LISTENING | awk '{print $5}' | head -1)
            if [[ -n "$pid" ]]; then
                taskkill //F //PID $pid 2>/dev/null || kill -9 $pid 2>/dev/null || true
                sleep 1
                return 0  # Retry
            fi
        fi
    fi

    # Check for missing node_modules
    if echo "$log_content" | grep -qE "MODULE_NOT_FOUND|Cannot find module"; then
        print_status "info" "Missing dependencies - running npm install"
        npm install > /dev/null 2>&1
        return 0  # Retry
    fi

    # For other errors, spawn an agent to diagnose and fix
    print_status "info" "Spawning agent to diagnose and fix $service_name..."

    # Export context for the prompt
    export SERVICE_NAME="$service_name"
    export LOG_FILE="$log_file"
    export PORT="$port"

    # Run the fix-service prompt
    run_prompt "fix-service"

    # Check if we should retry (agent may have fixed something)
    # We always retry unless max attempts reached
    return 0
}

# Start backend if needed
start_backend() {
    local max_retries=3
    local retry=0

    while [[ $retry -lt $max_retries ]]; do
        # Check if already running
        if curl -s "http://localhost:${LOOP_BACKEND_PORT}${LOOP_BACKEND_HEALTH}" > /dev/null 2>&1; then
            print_status "ok" "Backend already running on port ${LOOP_BACKEND_PORT}"
            # Reset failure counter on success
            TOTAL_SERVICE_FAILURES=0
            export TOTAL_SERVICE_FAILURES
            return 0
        fi

        local script=$(find_script "dev:api")
        if [[ -z "$script" ]]; then
            script=$(find_script "dev:backend")
        fi
        if [[ -z "$script" ]]; then
            script=$(find_script "start:api")
        fi

        if [[ -z "$script" ]]; then
            print_status "warn" "No backend script found in package.json"
            return 1
        fi

        print_status "info" "Starting backend ($script)..."
        # Clear previous log
        > /tmp/loop-backend.log
        nohup npm run "$script" > /tmp/loop-backend.log 2>&1 &
        local backend_pid=$!

        # Wait for backend to be ready (up to 30 seconds)
        for i in {1..30}; do
            if curl -s "http://localhost:${LOOP_BACKEND_PORT}${LOOP_BACKEND_HEALTH}" > /dev/null 2>&1; then
                print_status "ok" "Backend started successfully"
                return 0
            fi
            # Check if process died
            if ! kill -0 $backend_pid 2>/dev/null; then
                break  # Process died, exit wait loop
            fi
            sleep 1
        done

        # Backend didn't start - diagnose and potentially fix
        if diagnose_and_fix_service "Backend" "/tmp/loop-backend.log" "${LOOP_BACKEND_PORT}"; then
            ((retry++)) || true
            print_status "info" "Retrying backend startup ($retry/$max_retries)..."
            sleep 2
        else
            # External blocker or max attempts
            print_status "error" "Backend cannot be started automatically"
            return 1
        fi
    done

    print_status "error" "Backend failed to start after $max_retries attempts"
    return 1
}

# Start frontend if needed
start_frontend() {
    if curl -s http://localhost:${LOOP_FRONTEND_PORT} > /dev/null 2>&1; then
        print_status "ok" "Frontend already running on port ${LOOP_FRONTEND_PORT}"
        return 0
    fi

    # Check if frontend is in subdirectory
    if [[ -d "frontend" ]]; then
        print_status "info" "Starting frontend (frontend/npm run dev)..."
        cd frontend
        nohup npm run dev > /tmp/loop-frontend.log 2>&1 &
        cd ..
    else
        local script=$(find_script "dev:frontend")
        if [[ -z "$script" ]]; then
            script=$(find_script "dev")
        fi
        if [[ -n "$script" ]]; then
            print_status "info" "Starting frontend ($script)..."
            nohup npm run "$script" > /tmp/loop-frontend.log 2>&1 &
        fi
    fi

    # Wait for frontend to be ready
    for i in {1..20}; do
        if curl -s http://localhost:${LOOP_FRONTEND_PORT} > /dev/null 2>&1; then
            print_status "ok" "Frontend started successfully"
            return 0
        fi
        sleep 1
    done
    print_status "warn" "Frontend may not be fully ready (check /tmp/loop-frontend.log)"
}

# Start browser automation if needed
start_browser_automation() {
    if curl -s http://localhost:${LOOP_CDP_PORT}/json/version > /dev/null 2>&1; then
        print_status "ok" "Browser automation already running on port ${LOOP_CDP_PORT}"
        return 0
    fi

    # Find browser automation script
    local script=$(find_script "browser:")
    if [[ -z "$script" ]]; then
        script=$(find_script "automation:")
    fi

    if [[ -n "$script" ]]; then
        # Check for browser profiles (common locations)
        local profile_exists=false
        # Check common browser profile locations (project-agnostic)
        for profile_dir in "$HOME/.browser-profiles" "$HOME/.config/browser-profiles" "$HOME/.local/share/browser-profiles" "./browser-profiles"; do
            if [[ -d "$profile_dir" ]]; then
                profile_exists=true
                break
            fi
        done

        if $profile_exists; then
            print_status "info" "Starting browser automation ($script)..."
            nohup npm run "$script" > /tmp/loop-browser.log 2>&1 &

            # Wait for CDP to be ready (up to 30 seconds)
            for i in {1..30}; do
                if curl -s http://localhost:${LOOP_CDP_PORT}/json/version > /dev/null 2>&1; then
                    print_status "ok" "Browser automation started successfully"
                    return 0
                fi
                sleep 1
            done
            print_status "warn" "Browser automation may not be ready (check /tmp/loop-browser.log)"
        else
            print_status "warn" "No browser profile found - browser automation may require setup"
        fi
    else
        print_status "warn" "No browser service configured - needs INFRA task"
        print_status "info" "Add browser to services.yaml or create npm script"
        return 1
    fi
}

# Start all required services
# Uses v2 (docker/services.yaml) if available, otherwise legacy npm-based
start_required_services() {
    # Skip service startup if we've failed too many times
    # This prevents infinite startup loops and allows implementation to proceed
    if [[ $TOTAL_SERVICE_FAILURES -ge $MAX_TOTAL_SERVICE_FAILURES ]]; then
        print_status "warn" "Skipping service startup (too many failures: $TOTAL_SERVICE_FAILURES)"
        print_status "info" "Services may need manual intervention or implementation"
        return 0
    fi

    # Check if we should use v2 services (docker-compose, services.yaml)
    if should_use_services_v2 && type start_services_v2 &>/dev/null; then
        start_services_v2
        return $?
    fi

    # Legacy v1: VISION-based detection with npm scripts
    print_phase "SVC" "Service Startup (Ensuring Environment Ready)"

    # Start each service - failures are non-fatal but tracked
    # The service_check phase will handle any issues
    if vision_requires_backend; then
        if ! start_backend; then
            print_status "warn" "Backend startup failed - will be handled by service check"
            ((TOTAL_SERVICE_FAILURES++)) || true
            export TOTAL_SERVICE_FAILURES
        fi
    fi

    if vision_requires_frontend; then
        if ! start_frontend; then
            print_status "warn" "Frontend startup failed - will be handled by service check"
            ((TOTAL_SERVICE_FAILURES++)) || true
            export TOTAL_SERVICE_FAILURES
        fi
    fi

    if vision_requires_browser; then
        if ! start_browser_automation; then
            print_status "warn" "Browser startup failed - will be handled by service check"
            ((TOTAL_SERVICE_FAILURES++)) || true
            export TOTAL_SERVICE_FAILURES
        fi
    fi

    # Final status - only show services that VISION requires
    echo ""
    print_status "info" "Service status:"

    if vision_requires_backend; then
        curl -s "http://localhost:${LOOP_BACKEND_PORT}${LOOP_BACKEND_HEALTH}" > /dev/null 2>&1 \
            && echo "  Backend (${LOOP_BACKEND_PORT}):  ✓ Running" \
            || echo "  Backend (${LOOP_BACKEND_PORT}):  ✗ Not running"
    fi

    if vision_requires_frontend; then
        curl -s "http://localhost:${LOOP_FRONTEND_PORT}" > /dev/null 2>&1 \
            && echo "  Frontend (${LOOP_FRONTEND_PORT}): ✓ Running" \
            || echo "  Frontend (${LOOP_FRONTEND_PORT}): ✗ Not running"
    fi

    if vision_requires_browser; then
        curl -s "http://localhost:${LOOP_CDP_PORT}/json/version" > /dev/null 2>&1 \
            && echo "  Browser CDP (${LOOP_CDP_PORT}):  ✓ Running" \
            || echo "  Browser CDP (${LOOP_CDP_PORT}):  ✗ Not running"
    fi

    echo ""
}

# Check service status
check_service_status() {
    local service_name="$1"
    local check_cmd="$2"

    if eval "$check_cmd" > /dev/null 2>&1; then
        echo "RUNNING"
    else
        echo "NOT_RUNNING"
    fi
}

# Create a task to fix service startup - ONE UNIFIED APPROACH
# The implementation agent determines the specifics (install, configure, docker, etc.)
create_service_startup_task() {
    local service_name="$1"
    local task_id="SVC-$(date +%s | tail -c 4)"

    # Normalize service name for task matching
    local normalized=$(echo "$service_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/ /g' | xargs)

    # Check if task already exists
    if grep -qiE "SVC-.*$normalized|ensure.*$normalized.*starts" "$PLAN_FILE" 2>/dev/null; then
        print_status "info" "Service task for $service_name already exists"
        return 0
    fi

    print_status "warn" "$service_name needs setup - creating service task"

    # ONE task type - implementation agent figures out the details
    cat >> "$PLAN_FILE" << EOF

## Phase SVC: Service Setup (Auto-Generated)

- [ ] **$task_id**: Ensure $service_name starts reliably
  - **Requirement**: VISION requires this service to function
  - **Acceptance Criteria**:
    - Service starts automatically with project start command
    - Health check passes (service responds on expected port)
    - Configuration persists (works after restart)
    - Works across platforms (dev machines, CI/CD)
  - **Implementation**: Analyze project and choose appropriate method:
    - Add to services.yaml if using service config
    - Add to docker-compose.yml if using Docker
    - Create npm/project script if using package manager
    - Ensure any required software is installed
EOF

    print_status "ok" "Created task $task_id: Ensure $service_name starts"
}

# Run service readiness check and create fix tasks if needed
run_service_readiness_check() {
    print_phase "SVC" "Service Readiness Check (Production-Ready Verification)"

    echo ""
    print_status "info" "Checking if services auto-start with the application..."
    echo ""

    # Track services that need fix tasks
    local services_need_fix=()

    # Check each service that the loop tried to start
    # If it's not running AND the loop tried to start it, it's an architecture gap

    # Backend
    local backend_status=$(check_service_status "Backend" "curl -s http://localhost:${LOOP_BACKEND_PORT}${LOOP_BACKEND_HEALTH}")
    if [[ "$backend_status" == "NOT_RUNNING" ]]; then
        print_status "warn" "Backend: NOT_RUNNING"
        services_need_fix+=("Backend API server")
    else
        print_status "ok" "Backend: RUNNING"
    fi

    # Frontend
    local frontend_status=$(check_service_status "Frontend" "curl -s http://localhost:${LOOP_FRONTEND_PORT}")
    if [[ "$frontend_status" == "NOT_RUNNING" ]]; then
        print_status "warn" "Frontend: NOT_RUNNING"
        services_need_fix+=("Frontend dev server")
    else
        print_status "ok" "Frontend: RUNNING"
    fi

    # Browser automation (only if VISION requires browser)
    if vision_requires_browser; then
        local cdp_status=$(check_service_status "Browser automation" "curl -s http://localhost:${LOOP_CDP_PORT}/json/version")
        if [[ "$cdp_status" == "NOT_RUNNING" ]]; then
            print_status "warn" "Browser automation: NOT_RUNNING"
            services_need_fix+=("Browser automation")
        else
            print_status "ok" "Browser automation: RUNNING"
        fi
    fi

    # Return array via global variable (bash limitation)
    SERVICES_NEED_FIX=("${services_need_fix[@]}")
}
